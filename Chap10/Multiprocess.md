## 프로세스의 이해와 활용


하나의 서버에 수많은 클라이언트가 연결을 할 때, 전체적인 서비스 시간이 좀 늦어지더라도  
연결요청을 해오는 모든 클라이언트에게 동시에 서비스를 제공해서 평균적인 만족도를 높일 필요가 있다.

- 대표적인 다중접속 서버의 구현 모델.
 1. 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공.
 2. 멀티플렉싱 기반 서버 : 입출력 대상을 묵어서 관리하는 방식으로 서비스 제공
 3. 멀티쓰레딩 기반 서버 : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공.

### 프로세스
 : 메모리 공간을 차지한 상태에서 실행중인 프로그램
- 다운받아서 하드 디스크에 저장만 해놓으면 프로세스가 아닌 프로그램이다. '실행중'이 아니기 때문.
	실행하게되면 프로그램이 메인 메모리로 이동하여 실행 준비를 마치게 되는데 그 순간 프로세스가 된다.
- 프로세스는 운영체제의 관점에서 프로그램 흐름의 기본 단위가 되며, 여러 개의 프로세스가 생성되면 이들은 동시에 실행된다.
- 하나의 프로그램이 실행되는 과정에서 여러 개의 프로세스가 생성되기도 한다. ex) 멀티프로세스 기반의 서버

#### ※ CPU의 코어 수와 프로세스 수
- 두 개의 연산장치가 존재하는 CPU를 듀얼코어 CPU라 하고, 네 개는 쿼드코어 CPU라 한다.
- 이렇듯 CPU에는 실제 연산장치에 해당되는 코어가 둘 이상 존재할 수 있으며, 코어의 수만큼 프로세스 동시 실행이 가능하다.
- 코어의 수를 넘어서는 개수의 프로세스가 생성되면 프로세스 별로 코어에 할당되는 시간이 나뉘게 된다.
- CPU가 고속으로 프로세스를 실행하기 때문에 우리는 모든 프로세스가 동시에 실행되는 것처럼 느끼게 된다.

프로세스 ID : 생성되는 형태에 상관없이 모든 프로세스가 운영체제로부터 부여받는 ID.
- 2 이상의 정수. 1번은 운영체제가 시작되자마자 실행되는 프로세스에게 할당됨.

### fork 함수호출을 통한 프로세스 생성.

- fork 함수는 호출한 프로세스의 복사본을 생성한다. 전혀 새로운 프로그램을 바탕으로 프로세슬르 생성하는 것이 아니라 이미 실행중인, fork함수를 호출한 프로세스를 복사하는 것이다.
```c
#include <unistd.h>

pid_t fork(void);
// 성공시 프로세스 ID, 실패 시 -1 반환.
```

- fork 함수로 프로세스가 새로 만들어지면 두 프로세스는 모두 fork 함수 호출 이후의 문장을 실행한다.
- fork 함수의 반환 값을 기준으로 프로그램의 흐름을 구분해야 한다.
	1. 부모 프로세스(원본 프로세스) : fork 함수의 반환 값 : 자식 프로세스의 ID
	2. 자식 프로세스 : fork 함수의 반환 값 : 0
- 함수 실행 결과 부모, 자식 프로세스는 서로 완전히 분리된 메모리 구조를 지닌다.

> **부모 프로세스와 자식 프로세스는 순서에 관계없이 실행된다.**

-------------

## 좀비(Zombie) 프로세스
 : 프로세스가 생성되고 할 일을 다해도 사라지지 않고 시스템의 중요한 리소스를 차지하기도 하는 상태에 있는 프로세스.
 

#### 좀비 프로세스 생성 이유.
1. 인자를 전달하면서 exit를 호출하는 경우.
2. main 함수에서 return 문을 실행하면서 값을 반환하는 경우.

- exit 함수로 전달되는 인자 값과 main 함수의 return문에 의해 반환되는 값 모두 운영체제로 전달된다.  
- 그리고 운영체제는 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지 않는데 
	바로 이 상황에 놓여있는 프로세스를 좀비 프로세스라 한다.
- 즉, 자식 프로세스를 좀비 프로세스로 만드는 주체는 운영체제이다.

#### 자식 프로세스의 좀비 여부 확인하기
1. zombie.c 파일 실행.  
![1](https://user-images.githubusercontent.com/50162252/122644709-a1150e80-d151-11eb-899d-86efcf3af8ad.PNG)

2. 새 터미널 창을 열어서,  
![2](https://user-images.githubusercontent.com/50162252/122644729-b8ec9280-d151-11eb-944f-77ac57c349e1.PNG)
 - 사진과 같이 STAT(상태)가 Z
zombie.c 파일에서 지정한 시간이 지나면,  
![3](https://user-images.githubusercontent.com/50162252/122644775-e5081380-d151-11eb-8d44-df2af76f8ddd.PNG)

#### ※ ps au 실행 후 STAT 구분.

##### - 첫 번째 필드.
 - D : IO와 같이 중지(interrupt)시킬 수 없는 잠자고 있는 프로세스 상태.
 - R : 현재 동작중이거나 동작할 수 있는 상태.
 - S : 잠자고 있지만 중지시킬 수 있는 상태.
 - T : 작업 제어 시그널로 정지되었거나 추적중에 있는 프로세스 상태.
 - X : 완전히 죽어 있는 프로세스.
 - Z : 죽어 있는 좀비 프로세스.

##### - 두 번째, 세 번째 필드 코드.
 - < : 프로세스의 우선 순위가 높은 상태.
 - N : 프로세스의 우선 순위가 낮은 상태.
 - L : 실시간이나 기존 IO를 위해 메모리 안에 잠겨진 페이지를 가진 상태.
 - s : 세션 리더(주도 프로세스)
 - l : 멀티 쓰레드.
 - + : 포어그라운드(Foreground) 상태로 동작하는 프로세스.
	※ 포어그라운드 : 입력한 명령어의 실행이 결과가 나올 때까지 기다리는 방식.
 
#### ※ 후면처리(Background Processing)
  : 콘솔 창에서 명령어의 실행을 후면(뒤)에서 진행하도록 하는 방식.
  - 명령어 뒤에 '&'를 붙이면 그 명령은 background에서 수행된다. ex) ./z & 
  - 터미널 창을 두 개 열지 않고 두 명령어를 하나의 창에서 입력할 수 있다.