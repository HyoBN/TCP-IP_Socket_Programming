## TCP와 UDP에 대한 이해

> 인터넷 프로토콜 기반 소켓의 경우, 데이터 전송방법에 따라서 TCP 소켓과 UDP 소켓으로 나뉜다.

 ※ IP 자체는 비 연결지향적이며 신뢰할 수 없고 오류발생에 대한 대비가 되어있지 않은 프로토콜이다.

### TCP(Transmission Control Protocol)
 - 데이터 전송과정의 컨트롤이라는 뜻을 담고 있다.
 - 연결을 지향하기 때문에 스트림 기반 소켓이라고도 한다.
 - 신뢰성 있는 데이터의 전송을 담당한다.
 - IP를 기반으로 데이터를 보낸다. IP는 하나의 데이터 패킷이 전송되는 과정에만 중심을 두고 설계되어 여러 패킷을 전송할 때 문제가 발생한다.
 - => TCP는 데이터를 주고받는 과정에서 서로 데이터의 송수신을 확인함으로써 이러한 문제를 해결하고 데이터의 전송에 신뢰를 더한다.
 
------

### TCP/IP 프로토콜 스택(계층)

 - '인터넷 기반의 효율적인 데이터 전송'이라는 문제를 여러 계층화하여 해결하기 위해 만들어졌다.
 
 **LINK 계층 - IP 계층 - TCP 계층, UDP 계층 - APPLICATION 계층 총 4개의 계층으로 나뉜다.**
 
 - TCP 소켓을 생성해서 데이터를 송수신할 경우에는 TCP 계층을, UDP 소켓의 경우 UDP 계층을 통해 송수신한다.

 **1. LINK 계층.**
  - 물리적인 영역의 표준화에 대한 결과 == 물리 계층!
 
 **2. IP 계층.**
  - 목적지까지 데이터를 전송하기 위해 거쳐야할 경로를 정하는 계층.
  - 여기서 사용하는 프로토콜이 IP(Internet Protocol)이다.

 **3. TCP / UDP 계층.**
  - IP계층에서 알려준 경로 정보를 바탕으로 데이터의 실제 송수신을 담당하는 계층.
  - 전송(Transport) 계층이라고도 한다.
  - IP의 상위계층에서 호스트 대 호스트의 데이터 송수신 방식을 약속한다.
  
 **4. APPLICATION 계층.**
  - 응용프로그램들이 네트워크서비스, 메일서비스, 웹서비스 등을 할 수 있도록 표준적인 인터페이스를 제공하는 계층.
  
------

### TCP 서버에서의 기본적인 함수호출 순서.

**socket() -> bind() -> listen() -> accept() -> read()/write() -> close()**

socket() 함수를 통해 소켓을 생성하고, bind() 함수를 통해 소켓에 주소를 할당한 후,

#### 연결요청 대기상태로의 진입.
: 서버 소켓과 연결요청 대기 큐가 완전히 준비되어 클라이언트의 연결요청을 받아들일 수 있는 상태.

```c
int listen(int sock, int backlog);
```

 - sock : 연결요청 대기상태에 두고자 하는 소켓의 파일 디스크립터 전달. 서버 소켓(리스닝 소켓)이 된다.
 - backlog : 연결요청 대기 큐의 크기 정보 전달. ex) 5가 전달되면 클라이언트의 연결요청을 5개까지 대기시킬 수 있다.
 
 
#### 클라이언트의 연결요청 수락.

```c 
int accept(int sock, struct sockaddr *addr, socklent_t *addrlen);
```

 - sock : 서버 소켓의 파일 디스크립터 전달. 
 - addr : 연결요청한 클라이언트의 주소정보를 담을 변수의 주소 값 전달.
 - addrlen : addr에 전달된 주소의 변수 크기를 바이트 단위로 전달.
 
accept 함수 호출 성공시 내부적으로 데이터 입출력에 사용할 소켓을 생성하고 연결 요청한 클라이언트 소켓에 연결까지 이루어진다.

---- 

### TCP 클라이언트의 기본적인 함수호출 순서.
**socket() -> connect() -> read()/write() -> close()**
