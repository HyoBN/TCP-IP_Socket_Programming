## TCP와 UDP에 대한 이해

> 인터넷 프로토콜 기반 소켓의 경우, 데이터 전송방법에 따라서 TCP 소켓과 UDP 소켓으로 나뉜다.

 ※ IP 자체는 비 연결지향적이며 신뢰할 수 없고 오류발생에 대한 대비가 되어있지 않은 프로토콜이다.

### TCP(Transmission Control Protocol)
 - 데이터 전송과정의 컨트롤이라는 뜻을 담고 있다.
 - 연결을 지향하기 때문에 스트림 기반 소켓이라고도 한다.
 - 신뢰성 있는 데이터의 전송을 담당한다.
 - IP를 기반으로 데이터를 보낸다. IP는 하나의 데이터 패킷이 전송되는 과정에만 중심을 두고 설계되어 여러 패킷을 전송할 때 문제가 발생한다.
 - => TCP는 데이터를 주고받는 과정에서 서로 데이터의 송수신을 확인함으로써 이러한 문제를 해결하고 데이터의 전송에 신뢰를 더한다.
 
------

### TCP/IP 프로토콜 스택(계층)

 - '인터넷 기반의 효율적인 데이터 전송'이라는 문제를 여러 계층화하여 해결하기 위해 만들어졌다.
 
 **LINK 계층 - IP 계층 - TCP 계층, UDP 계층 - APPLICATION 계층 총 4개의 계층으로 나뉜다.**
 
 - TCP 소켓을 생성해서 데이터를 송수신할 경우에는 TCP 계층을, UDP 소켓의 경우 UDP 계층을 통해 송수신한다.

 **1. LINK 계층.**
  - 물리적인 영역의 표준화에 대한 결과 == 물리 계층!
 
 **2. IP 계층.**
  - 목적지까지 데이터를 전송하기 위해 거쳐야할 경로를 정하는 계층.
  - 여기서 사용하는 프로토콜이 IP(Internet Protocol)이다.

 **3. TCP / UDP 계층.**
  - IP계층에서 알려준 경로 정보를 바탕으로 데이터의 실제 송수신을 담당하는 계층.
  - 전송(Transport) 계층이라고도 한다.
  - IP의 상위계층에서 호스트 대 호스트의 데이터 송수신 방식을 약속한다.
  
 **4. APPLICATION 계층.**
  - 응용프로그램들이 네트워크서비스, 메일서비스, 웹서비스 등을 할 수 있도록 표준적인 인터페이스를 제공하는 계층.
  
------

### TCP 서버에서의 기본적인 함수호출 순서.

**socket() -> bind() -> listen() -> accept() -> read()/write() -> close()**

socket() 함수를 통해 소켓을 생성하고, bind() 함수를 통해 소켓에 주소를 할당한 후,

#### - 연결요청 대기상태로의 진입.
: 서버 소켓과 연결요청 대기 큐가 완전히 준비되어 클라이언트의 연결요청을 받아들일 수 있는 상태.

```c
int listen(int sock, int backlog);
```

 - sock : 연결요청 대기상태에 두고자 하는 소켓의 파일 디스크립터 전달. 서버 소켓(리스닝 소켓)이 된다.
 - backlog : 연결요청 대기 큐의 크기 정보 전달. ex) 5가 전달되면 클라이언트의 연결요청을 5개까지 대기시킬 수 있다.
 
 
#### - 클라이언트의 연결요청 수락.

```c 
int accept(int sock, struct sockaddr *addr, socklent_t *addrlen);
```

 - sock : 서버 소켓의 파일 디스크립터 전달. 
 - addr : 연결요청한 클라이언트의 주소정보를 담을 변수의 주소 값 전달.
 - addrlen : addr에 전달된 주소의 변수 크기를 바이트 단위로 전달.
 
accept 함수 호출 성공시 내부적으로 데이터 입출력에 사용할 소켓을 생성하고 연결 요청한 클라이언트 소켓에 연결까지 이루어진다.

---- 

### TCP 클라이언트의 기본적인 함수호출 순서.
**socket() -> connect() -> read()/write() -> close()**

#### - 연결요청.

```c 
int connect(int sock, struct sockaddr *aservaddr, socklen_t addrlen);
```

 - sock : 클라이언트 소켓의 파일 디스크립터 전달.
 - servaddr : 연결 요청할 서버의 주소정보를 담은 변수의 주소 값 전달.
 - addrlen : 두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달.
 
connect() 함수가 호출되면 다음 둘 중 한 가지 상황이 되어야 함수호출이 완료된다.
 1. 서버에 의해 연결요청이 접수됨.
 2. 네트워크 단절 등 오류상황이 발생해 연결요청이 중단됨.

1에서 '연결요청의 접수'란 서버의 accept() 함수호출이 아니라 클라이언트의 연결요청 정보가 서버의 연결요청 대기 큐에 등록된 상황을 의미한다.
-> connect 함수가 반환했더라도 당장에 연결이 이루어지지 않을 수도 있다.

---------

## Iterative 기반의 서버, 클라이언트 구현.

#### Iterative 서버 : 한 순간에 하나의 클라이언트에게만 서비스를 제공하는 서버.

### Iterative 서버의 함수호출 순서.

* socket() -> bind() -> listen() -> accept() -> read()/write() -> close(client) -> close(client) -> close(server)
* 계속 들어오는 클라이언트의 연결 요청을 수락하기 위해서 -> 반복문을 삽입해서 accept() 부터 close(client)를 반복!

### 동작 방식.

1. 서버는 한 순간에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
2. 서버는 총 n개의 클라이언트에게 순차적으로 서비스를 제공하고 종료한다.
3. 클라이언트는 프로그램 사용자로부터 문자열 데이터를 입력 받아서 서버에 전송한다.
4. 서버는 전송 받은 문자열 데이터를 클라이언트에게 재전송한다. 즉, 에코 시킨다.
5. 서버와 클라이언트간의 문자열 에코는 클라이언트가 Quit를 입력할 때까지 계속한다.



위의 조건을 만족하도록 echo_server.c 와 echo_client.c 를 구현.










