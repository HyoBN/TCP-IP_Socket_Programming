
# TCP의 이론적인 이야기.

## TCP 소켓에 존재하는 입출력 버퍼.

> TCP 소켓의 데이터 송수신에는 경계가 없다. 즉, 서버가 한번의 write 함수호출을 통해 40바이트를 전송해도
> 클라이언트는 네 번의 read 함수호출을 통해 10바이트씩 데이터를 수신하는 것이 가능하다.

### 서버가 한 번에 40바이트를 전송했는데, 클라이언트가 10바이트씩 끊어서 수신하면 나머지 30바이트는 어디서 대기하는 것인가?
- write 함수가 호출되는 순간이 데이터가 전송되는 순간이 아니다.
- read 함수가 호출되는 순간이 데이터가 수신되는 순간도 아니다.
- 정확히 말하면 write 함수가 호출되는 순간 데이터는 출력버퍼로 이동하고
- read 함수가 호출되는 순간 입력버퍼에 저장된 데이터를 읽어 들이게 된다.
- 즉, '버퍼' 라는 공간을 거쳐 데이터가 송수신되는 것이다.

### 입출력 버퍼의 특성.
- 입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재한다.
- 입출력 버퍼는 소켓생성시 자동으로 생성된다.
- 소켓을 닫아도 출력버퍼에 남아있는 데이터는 계속해서 전송이 이뤄진다.
- 소켓을 닫으면 입력버퍼에 남아있는 데이터는 소멸되어버린다.

## TCP의 내부 동작원리.

TCP 소켓의 생성에서 소멸의 과정까지 3단계로 구분할 수 있다.

> **상대 소켓과의 연결 -> 데이터 송수신 -> 연결종료.**

### 1. 상대 소켓과의 연결.
> TCP 소켓은 연결설정 과정에서 총 세 번의 대화를 주고 받는다. : Three-way handshaking.

1. 연결요청을 하는 A가 B에게, '[SYN] SEQ: 1000, ACK : -'  
   SEQ 1000 의 의미 : *"내가 지금 보내는 이 패킷에 1000이라는 번호를 부여하니, 잘 받았다면 다음에는 1001번 패킷을 전달하라고 내게 말해달라!".*  
   SYN : Synchronization의 줄임말, 동기화 메시지라는 의미.  

2. B가 A에게, '[SYN+ACK] SEQ: 2000, ACK: 1001'  
   SEQ 2000 의 의미 : *"내가 지금 보내는 이 패킷에 2000이라는 번호를 부여하니, 잘 받았다면 다음에는 2001번 패킷을 전달하라고 내게 말해달라!".*  
   ACK 1001 의 의미 : *"좀 전에 전송한 SEQ가 1000인 패킷은 잘 받았으니, 다음 번에는 SEQ가 1001인 패킷을 전송하기 바란다."*  
   A가 전송한 패킷에 대한 응답 메시지(ACK 1001)과 함께 B의 데이터 전송을 위한 동기화 메시지(SEQ 2000)을 함께 묶어서 보내기 때문에 [SYN+ACK]의 메시지 유형을 가짐.  
  
3. A가 B에게, '[ACK] SEQ: 1001, ACK: 2001'

### 2. 상대 소켓과의 데이터 송수신.

A가 B에게 SEQ 1200으로 100byte의 데이터를 전송한다면,
B는 ACK 1301 메시지를 담은 패킷을 A에게 전송한다.

> *1201이 아니라 1301인 이유는 패킷에 담긴 100바이트의 데이터가 전부 전송되었는지 알기 위해서이다.*

즉, 다음의 공식을 기준으로 ACK 메시지를 전송한다.
> ACK 번호 : SEQ 번호 + 전송된 바이트 크기 +1

### 3. 상대 소켓과의 연결종료.

1. 먼저 A가 종료 메시지를 B에게 전달하고, 
2. B는 해당 메시지의 수신 여부를 A에게 알린다.
3. 그리고 B가 종료 메시지를 A에게 전달하고, 
4. A는 해당 메시지의 수신을 B에게 알린다.

-> **Four-way handshaking**
 