# IO 멀티플렉싱 기반의 서버

#### 멀티프로세스 기반 서버의 단점과 대안.

 - 프로세스 생성에는 많은 양의 연산과 메모리 공간이 요구된다.
 - 프로세스마다 별도의 메모리 공간을 쓰기 때문에 데이터 송수신을 위해 다소 복잡한 방법을 사용해야 한다.
프로세스를 생성하지 않고 다중접속 서버를 구현하는 방법이 존재한다!

#### 멀티플렉싱이란?
 : 하나의 통신 채널을 통해서 둘 이상의 데이터를 전송하는데 사용되는 기술.

 - 최소한의 물리적 요소만 사용해서 최대한의 데이터를 전달하기 위해 사용되는 기술.
 - select 함수를 이용하는 것이 멀티플렉싱 서버의 구현에 있어서 가장 대표적인 방법이다.
 
## select 함수를 통한 서버 구현

select 함수를 사용하면 한 곳에 여러 개의 파일 디스크립터를 모아서 동시에 이들을 관찰할 수 있다.

 - 수신한 데이터를 지니고 있는 소켓이 존재하는지?
 - 블로킹되지 않고 데이터의 전송이 가능한 소켓은 무엇인지?
 - 예외상황이 발생한 소켓은 무엇인지?
와 같은 항목을 관찰할 수 있다. 이 항목을 각각 event라 한다.

### select 함수 호출 과정.
 : 파일 디스크립터, 검사의 범위, 타임아웃 설정 -> select 함수 호출 -> 호출결과 확인.
 
#### 1. 파일 디스크립터 설정.
 - 관찰항목(수신, 전송, 예외)에 따라 파일 디스클립터를 구분하여 모아야 한다.
 - 이렇게 세 묶음으로 모을 때 fd_set형 변수를 사용한다.
	- fd_set형 변수는 0과 1로 표현되는 비트 단위로 이루어진 배열이다.
	- 배열의 인덱스가 1이면 해당 인덱스의 파일 디스크립터가 관찰 대상임을 의미한다.
	- fd_set형 변수에 값을 등록하거나 변경할 때에는 매크로 함수를 통해 이뤄진다.
		- 1. FD_ZERO(fd_set *fdset): fdset을 모두 0으로 초기화.
		- 2. FD_SET(int fd, fd_set *fdset) : fdset에 fd로 전달된 파일 디스크립터 정보를 등록한다.
		- 3. FD_CLR(int fd, fd_set *fdset) : fdset에 fd로 전달된 파일 디스크립터 정보를 삭제한다.
		- 4. FD_ISSET(int fd, fd_set *fdset) : fdset에 fd로 전달된 파일 디스크립터 정보가 있으면 양수를 반환한다.

```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
// 성공시 0이상, 실패 시 -1 반환.
```
#### select 함수의 각 매개변수.  
 - maxfd : 검사 대상이 되는 파일 디스크립터 수.
 - readset : fd_set형 변수에 '수신된 데이터의 존재여부'에 관심있는 파일 디스크립터 정보를 모두 등록, 주소값 전달.
 - writeset : fd_set형 변수에 '블로킹 없는 데이터 전송의 가능여부'에 관심있는 파일 디스크립터 정보를 모두 등록, 주소값 전달.
 - exceptset : fd_set형 변수에 '예외상황의 발생여부'에 관심있는 파일 디스크립터 정보를 모두 등록, 주소값 전달.
 - timeout : select 함수호출 이후 무한정 블로킹에 빠지지않도록 타임아웃을 설정하기 위한 인자 전달.
 - 반환값 : 변화가 발생한 파일 디스크립터의 수 의미 / 오류 발생시 -1 반환.
 