# 쓰레드의 이론적 이해.

### 멀티프로세스 기반의 단점.
1. 프로세스 생성이라는 부담스러운 작업과정을 거친다.
2. 두 프로세스 사이 데이터 교환을 위해서는 별도의 IPC 기법을 적용해야한다.
3. 초당 수천 번까지 일어나는 컨텍스트 스위칭에 따른 부담이 크다.

### 멀티쓰레드의 장점.
1. 쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다.
2. 쓰레드 사이 데이터 교환에는 특별한 기법이 필요하지 않다.
- 즉, 멀티프로세스의 여러 단점을 최소화시킬 수 있다.

프로세스 : 운영체제 관점에서 별도의 실행흐름을 구성하는 단위.  
쓰레드 : 프로세스 관점에서 별도의 실행흐름을 구성하는 단위.  

즉, 한 프로세스 내에서 여러 쓰레드가 실행가능하며, 이들은 동일한 데이터, 힙 영역을 가지기 때문에  
별도의 방법을 사용하지 않고 이를 통해서 쓰레드 간 통신이 가능하다.


- 쓰레드 생성 함수(pthread_create()) 예제) thread1.c 
	- gcc thread1.c -o tr1 -lpthread 로 실행하여야 한다.
	- -lpthread 옵션을 추가하여 쓰레드 라이브러리의 링크를 별도로 지시해야 pthread.h에 선언된 함수들을 호출할 수 있다.

##### 쓰레드의 실행 흐름을 조절하는 함수.

```c
#include <pthread.h>

int pthread_join(pthread_t thread, void** status);
// 성공 시 0, 실패 시 0 이외의 값 반환.

```

- thread : 이 매개변수에 전달되는 ID의 쓰레드가 종료될 때까지 함수는 반환하지 않는다.
- status : 쓰레드의 main 함수가 반환하는 값이 저장될 포인터 변수의 주소 값을 전달한다.

즉, pthread_join 함수는 첫 번째 인자로 전달되는 ID의 쓰레드가 종료될 때까지 이 함수를 호출한 프로세스 혹은 쓰레드를 대기 상태에 둔다.  
또한, 쓰레드의 main 함수가 반환하는 값까지 얻을 수 있다.(status 변수)

------------

- 여러 개의 쓰레드를 생성하여 동시에 호출하면 문제를 일으키는 함수가 존재한다.  
- 임계영역(Critical Section) : 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 코드블록.
- 쓰레드에 안전한 함수(Thread-safe function) : 다수의 쓰레드에 의해 동시 호출 및 실행되어도 문제를 일으키지 않는 함수. 반대: Thread-unsafe function.

일반적으로 쓰레드에 안전한 형태로 재 구현된 함수의 이름 뒤에는 _ r이 붙는다.  
또한 헤어파일 선언 이전에 매크로 _ REENTRANT를 정의하면 자동으로 _ r을 붙여주는 효과를 얻을 수 있다.  
컴파일 시, -D_REENTRANT 옵션을 추가하는 방식으로도 매크로롤 정의할 수 있다. ex) gcc -D_REENTRANT thread2.c -o -lpthread  

